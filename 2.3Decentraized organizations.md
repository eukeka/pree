
# 非集中型構成：P2Pシステム
* 分散アプリケーションにおける多層クライアント/サーバー・アーキテクチャの構成は以下からなる．
  1. ユーザー・インターフェース
  2. 処理コンポーネント
  3. データ管理コンポーネント
* 多くのビジネス環境での分散処理とは，この三層アーキテクチャとして構成することと言える．
  * このタイプを垂直分散と呼ぶ．
    * 垂直分散の特徴は，異なるコンポーネントを異なるマシンに配置することによって達成される．

<br>

* 現代のアーキテクチャでは，クライアントおよびサーバの分散が重要であり，水平分散と呼ぶ．
  * このタイプでは，クライアントやサーバーを物理的または論理的に同等の部分に分割し，各部分は完全なデータセットとして動作し，負荷を分散する．
* この章では，P2Pシステムと呼ばれる水平分散をサポートする最新のシステム・アーキテクチャのクラスを見る．

<br>

* ピアツーピアシステムを構成するプロセスはすべて等しい．
  * つまり，実行に必要な機能は，分散システムを構成する全てのプロセスによって表される．
  * 結果として，プロセス間の相互作用の多くは対称的であり，各プロセスは同時にクライアントとサーバとして動作します（サーバントとも呼ばれる）
  * ノードは各プロセスによって表され，任意の他のノードと直接通信することはできないが，利用可能な通信チャネルを介してメッセージを送信する必要がある．
* この対称的な振る舞いを考えると，P2Pアーキテクチャでは，オーバーレイネットワークにおけるプロセスをどのように構成するかという問題に発展する

<br>

* オーバーレイネットワークには，構造化されたものとそうでないものがある．これらの2つのタイプは，Lua et al．[2005]にいくつか例がある．
  * Buford and Yu [2010]は，さらにさまざまなP2Pシステムの多くが含まれている．
  * Aberer et al [2005]は，異なる種類のP2Pシステムの比較について提供している．
  * Androutsellis-Theotokis and Spinellis [2004]は，コンテンツ配信の観点から行われた調査を提供している．
  * Buford et al． [2009]，Tarkoma [2010]とVu et al． [2010]は，研究のための適切なテキストブックを作成した．

<br>

## 構造型P2Pシステム
* 構造化P2Pシステムでは，リング，ツリー，グリッドなどの特定の決定論的トポロジに従ったオーバーレイによってノード(つまり，プロセス)が編成される．
  * オーバーレイは，データを効率的に検索するために使用する．
  * 構造化P2Pシステムの特徴は，システムによって保管される各データが一意なキーに関連付けられ，このキーがその後にインデックスとして使用される．
  * キーにはハッシュ関数を使用するのが一般的である．例えば次のようになる．
```
    key(data item) = hash(data item’s value).  
```


* 今では，ピアツーピアシステム全体が（キー，バリュー）のペアを格納する役割を担っている．
  * 各ノードには，ハッシュ値から識別子が割り当てられ，キーに関連付けられたデータを格納する役割を担う．
  * システムはDHT [Balakrishnan et al．，2003]と略される分散ハッシュテーブルを実装する．
* このような，キーを使用してデータをLookupできるようになることが構造化されたP2Pシステムの本質だと言える．
* つまりシステムは，キーを既存のノードにマップするLookup関数の効率的な実装を提供することになる．
```
    existing node = lookup(key).
```
* これは，構造化P2Pシステムのトポロジが重要な役割を果たす場面である．
  * 任意のノードは，キーをlookupするように要求され，キーに関連するデータを格納しているノードにたどり着くまで，その要求を効率的にルーティングする．

<br>

##### Lookupの例
* これらを明確にするために，超立方体に整理された固定数のノードを持つ簡単なP2Pシステムを考えてみる（図2.18）．
  * 超立方体はn次元の立方体であり，図2.18に示す超立方体は4次元である．
  * これは，2つの通常の立方体が相互に接続されているように考えることができる．
  ![図2.18](./images/02-18.png)
  * このシステムでは，各データは16のノードの1つに関連付けられている．
  * これは，データの値に対してキー k∈{0，1，2 ，... ，24-1}とする．
  * ここでは，識別子0111を有するノードが，バイナリ値1110に対応するキー14を有するデータをLookupするよう要求されると仮定する．
  * この例では，識別子1110を有するノードがキー14を有するすべてのデータ項目を格納することを担当すると仮定する．
    * 0111は簡単にノードを探すために，ノード1110に近い近隣に要求を転送する．
    * この場合，これはノード0110またはノード1111のいずれかである．
    * ノード0110を選択すると，そのノードは，1110からデータを取り出すことができる．

## ノート2.5（Chordシステムの例）
![図2.19](./images/02-19.png)
* 以前の例（超立方体のトポロジ）で示したこと
  1. データを格納するノードを識別するためのハッシュ関数の使用，
  2. データをLookupするときのP2Pシステムのトポロジに沿ったルーティング．
* しかし，非常に現実的な例ではない
  * なぜなら，ノードの総数が固定されていると仮定したため．
  * したがって，実際に使用される構造化P2Pシステムの現実的な例を検討する

<br>

* Chordシステム[Stoica et al．，2003]は論理的なリング状の構造を持つ．
  * これにより，ノードをmビット範囲にキーkをマッピングする．（mビットのid ≧ k）.
  * キーkが割り当てられているノードのことをSuccessorと呼び，succ(k)と表す．(キーの範囲は通常128から160ビット)

* 図2.19は小さなChordリングを表している．
  * キー7のSuccessorは9になり，同様にsucc(5)=9,succ(9)=9となる．
* Chordでは，ノードはショートカットを使う．
  * ショートカットは他のノードへのダイレクトな経路となる．（どのようにこのショートカットが構成されるのかについては，5章で説明する）．
  * この構造は，任意のノードまでの最短経路の長さがO（log N）であるように行われる(Nはノードの総数）．
  * キーをLookupするために，ノードは要求を「可能な限り」転送するように試みるが，そのキーを担当するノードを超えて渡すことはない．

**Chordの探索手順**
* 説明するために，例のChordリングでは，ノード9はキー3を担当するノードをLookupするように求められているとする.
    * ノード9には，ノード11，14，18，および28の4つのショートカットがある．
    * ノード28は，最も遠いノード9がキー3を担当するノード9を知っていて，それに先立っているので，Lookup要求を受け取ることになる．
    * ノード9はもっとも遠いノード28がキー3に一番近いと判断し，ノード28にLookup要求を渡す．
    * ノード28は3つのショートカットを持っている：1,4,14
      * （メモ）ノード28はノード1と4の間に何が存在するかしらない．
      * なぜなら，ノード1にリクエストを転送することがベストだからノード1に転送する．
      * そのあと，ノード1はリング内の後続ノードがノード4であることを知っているため，これがキー3を担当するノードとなる．


**Chordの参加手順**
  * 一意の識別子uを持つノードがChordオーバーレイに加わりたいとする．
    * 任意のノードに接続し，uをLookupするよう要求する．
    * つまり，v = succ（u）を返す．
  * その時点で，ノードuは，vとそのPredecessorの間にそれ自身を挿入するだけでよいので，vの新しいSuccessorになる．
  * このプロセスではuから他のノードへのショートカットが確立されるが，以前にvへ向けられた既存のものもuを指すように調整される（詳細は後の章で述べる）．

  * 離脱は単純．
    * ノードuはそのSuccessorとPredecessorに離脱を通知し，そのデータアイテムをsucc（u）に転送する．


## 非構造型P2Pシステム
* 構造化されたP2Pシステムは，特定の決定論的オーバーレイネットワークを維持しようとする．
* 対照的に，非構造型P2Pシステムでは，各ノードは隣接ノードの特別なリストを維持する．
  * 得られたオーバーレイは，ランダムグラフと呼ばれるものに似ている．
   [ランダムグラフ](https://image.slidesharecdn.com/complexnetworkchap4-120131100148-phpapp01/95/-8-728.jpg?cb=1328089252)

* このリストを使用して，より多くのピアを見つけたり，他のものを無視したりすることができる．実際には，ノードはローカルリストを連続的に変更する．
  * 例えば，ノードは，近隣のノードの応答がないことで変更の必要に気づくことができる．
  * 他にも，このあと説明する理由がある．

* 構造化されたP2Pシステムとは異なり，近隣のリストが特殊な方法で構成されている場合，データ探索は所定の経路に従うことができない．
* 代わりに，非構造化P2Pアシステムでは，データ検索に本当に必要なものがある[Risson and Moors，2006].

* 2つの極端な例を見て，特定のデータ（キーワードなどで特定されたもの）を検索する場合を考える.

### Flooding
* フラッディングの場合，始点ノードuは，データ要求を全ての隣接ノードに単純に渡す．
* vは要求されたデータ項目をローカルで検索する．もしvが必要なデータを持っていれば，それは発行ノードuに直接応答するか，元のフォワーに戻す.
* もしもvがデータを持っていなければ近隣のノードにリクエストを転送する．
* フラッディングは非常にコストが高くなる可能性がある．
  * そのため，要求には生存時間またはTTL値が関連付けられていることが多く，要求の転送が許可される最大ホップ数が与えられる．
* 適切なTTL値を選択することは非常に重要．
  * 小さすぎるとデータを持つノードに到達しない可能性がああり，大きすぎると通信コストが高くなる．
* TTL値を設定する代わりに，ノードは最初のTTL値が1である検索を開始することもできる．
  * つまり，最初に隣接ノードのみを照会する．
  * 失敗した場合，TTLを増加して新しい検索が開始される．

### Random walks
* 他の探索スペクトルとして，発行ノードuはランダムに選択された隣人，例えばvを求めることによってデータ項目を見つけることができる．
  * vがデータを持たない場合は，ランダムに選択されたノードに要求を転送する．
  * これをランダムウォークという[Gkantsidis et al., 2006; Lv et al., 2002].

* ランダムウォークはトラフィックを大幅に少なくするが，データを持つノードに到達するまでにはかなりの時間がかかることがある．
* 時間を短縮するために，ランダムウォークを同時に実行することも可能

* ランダムウォークも要求の最大(TTLなど)を決める必要がある．
  * この場合，TTLを再度使用するか，または送信元に，別のランダムに選択された隣接ノードへの要求を転送するようにする．

**ノート**  
* どちらの方法も，要求したデータが見つかったかどうかを特定の比較手法を使用して，要求されたデータが見つかったときを決定していないことに注意してください
  * 構造化P2Pシステムでは，比較のためにキーの使用を前提としていた．
  * 今説明した2つのアプローチでは，どのような比較手法でも問題ない．
