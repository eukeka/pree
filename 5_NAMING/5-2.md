# 5.2 フラットネーミング
## 分散ハッシュテーブル
* Chordの話
* 省略

## 階層型アプローチ
* 階層スキームでは，ネットワークはドメインの集合に分割される．
  * ネットワーク全体にまたがる単一のトップレベルドメインが存在する．
  * 各ドメインは複数の小さなサブドメインに細分することができます．
* リーフドメインと呼ばれる最低レベルのドメインは，コンピュータネットワーク内のLANまたは携帯電話ネットワーク内のセルに対応する．
* 一般的な前提
  * あるドメインから別のドメインにメッセージを転送するのに要する平均時間は，ドメインが近い方が早い
* 各ドメインをDとすると，そのドメイン内のエンティティを追跡するため，ドメインDは関連づけられたディレクトリノードdir（D）を有する
  * これは，ディレクトリノードによりツリーで表されることを意味する
  *  ルート（ディレクトリ）ノードと呼ばれるトップレベルドメインのディレクトリノードは，すべてのエンティティについて知っている（図5.6）

![5.6](images/05-06.jpg)

**階層構造の説明（記号の例えが分かりにくい（））**
* 現在のドメインDに所属する各エンティティは，場所を辿ることができるようにドメインDのディレクトリノードdir（D）内のロケーションレコードによって表される
* リーフドメインDにあるディレクトリノードNが持つエンティティEの位置情報(location record)は，そのドメイン内のエンティティのアドレスを含む
* 対照的に，Dを含んだより高いレベルのドメインD'が持つディレクトリノードN’は，サブディレクトリを辿れるように，エンティティEを持つNへのポインタを記録する．
* 同様に，N'の親ノードについても，エンティティEへ辿るために，N'へのポインタのみを記録する．
* 結果として，ルートノードは各エンティティの位置情報(location record)を持つことになり，それぞれの位置情報は，そのレコードの関連エンティティが現在位置している次の下位レベルのサブドメインのディレクトリノードへのポインタを格納する


**ツリーの構成**
* エンティティは，複製されている場合などに複数のアドレスを持つことができる．
* エンティティがリーフドメインD1とD2にそれぞれアドレスを持つ場合
  * D1とD2の両方を含む最小のドメインのディレクトリノードは，アドレスを含む各サブドメインに1つずつ，2つのポインタを持つ．
  * 図5.7に示すようなツリーの一般的な構成につながる．

![5.7](images/05-07.jpg)

**ルックアップ手順**
* 階層的なロケーションサービスでルックアップ操作がどのように進行するか考える．
* 図5.8に示すように，クライアントがエンティティE（右下の黒い四角のノード）を探したい場合，クライアントが所属するリーフドメインD（左下）のディレクトリノードにルックアップ要求を発行する．
  * ディレクトリノードがエンティティの位置記録を格納していない場合，エンティティは現在Dに位置していない．
  * 結果，ノードは要求をその親に転送する．
  * 親にもEのロケーションレコードがない場合，ルックアップ要求は次のレベルに転送され以下同様に続く．

![5.8](images/05-08.jpg)

* 要求がディレクトリノードMに達すると，EはノードMによって表されるドメインdom（M）のどこかにあることがわかる．
* 図5.8を見ると，Mはそのサブドメインの1つへのポインタを含むロケーションレコードを格納するように示されている．
* ルックアップ要求は，そのサブドメインのディレクトリノードに転送され，そのサブドメインは，要求が最終的にリーフノードに到達するまでツリーのさらに下に転送する．
* リーフノードに格納されたロケーションレコードは，そのリーフドメインにEのアドレスを含む．
* 見つかったアドレスは，最初にルックアップを要求したクライアントに返すことができる．

**階層型ロケーションの重要ポイント**
* 階層的ロケーションサービスに関する重要な点は，ルックアップ操作が局所性を利用することである．
* 原則としてエンティティは，要求元のクライアントを中心とした徐々に増加するリング内で検索される．
* 探索領域は，ルックアップ要求が次のより高いレベルのディレクトリノードに転送されるたびに展開される．
* 最悪の場合，要求はルートノードに到達するまで続く．
  * ルートノードは各エンティティの位置情報を持つため，リクエストはリーフノードの1つへのポインタの下向き経路に沿って単純に転送される．

**更新操作**
* 更新操作は，図5.9に示すように同様の方法で局所性を利用する．
* エンティティEのレプリカをリーフドメインD内のアドレスに挿入する場合を考える．

    1. 挿入はDのリーフノードdir（D）で開始され，Dはその挿入要求をその親に転送する．
    2. 親はすでにEの位置情報を格納しているディレクトリノードMに到達するまで挿入要求を転送する．

  ![5.8](images/05-09a.jpg)

    3. ノードMは挿入要求が転送された子ノードを参照してEの位置情報のポインタを格納する．
    4. Mの子ノードはEの位置情報を作成し，下位レベルノードへのポインタを含む．
    5. このプロセスは，挿入が開始されたリーフノードに到達するまで続く．

  ![5.8](images/05-09b.jpg)

    6. リーフノードは，最後に関連付けられたリーフドメイン内のエンティティのアドレスを持つレコードを作成する．

**ポインタのチェーンはトップダウン形式でインストールされる**
* 上記のようにアドレスを挿入すると，エンティティEのロケーションレコードを持つ最下位レベルのディレクトリノードから開始して，ポインタのチェーンをトップダウン形式でインストールすることになる．
* 階層型の利点はアドレスができるだけ早くルックアップに利用できるようになることにある．
* アドレスの検索の際に，親ノードに一時的に到達できない場合にも現在のノードによって表されるドメイン内で引き続き検索することができる．

----
